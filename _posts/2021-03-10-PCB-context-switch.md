---
title: OS | 문맥교환과 PCB란?
tags: [OS, Context Switch, PCB]
date: 2021-03-09 20:11:00 +09:00
categories: [OS]

---

문맥교환은 무엇이고 문맥교환시 사용되는 PCB에 대해 알아보겠습니다.

<!--more-->
---

## 문맥교환(Context Switch)이 무엇인가요?

시분할 시스템에서 CPU는 한 프로세스에 계속 머무는 것이 아닌 여러 프로세스를 옮겨다니면서 조금씩 수행합니다.  이 때 기존의 프로세스에 처리중이던 정보를 어디에 저장해놔야 다시 돌아왔을때 기존 정보를 이어서 작업할 수 있습니다. 이 때 이 저장해야되는 정보를 **문맥(Context)**라고 하면 CPU의 제어권이 처리중이던 프로세스에서 다른 프로세스로 이양되는 과정을 **문맥교환**이라고 말합니다. 

문맥교환시 실행중이던 프로세스의 문맥을 저장해두는 곳을 **PCB(Process Control Block)**라고 합니다. PCB는 모든 프로세스마다 있으며 프로세스가 실행시 자동으로 커널의 데이터 영역에 생성됩니다.

<br/>


## PCB가 저장되는 커널영역이란? (참고)

<img data-action="zoom" src='{{ "/assets/images/2021-03-10-PCB/1커널의 코드,데이터,스택영역.png" | relative_url }}'  width=600 alt='absolute'>

실제 메모리중 운영체제와 관련되 부분이 적재되는 곳을 **커널영역**이라고 합니다.
커널영역에는 코드영역, 데이터 영역, 스택 영역이 있습니다.
**코드 영역**에는 운영체제가 잘 수행되어야할 명령들의 코드들이 저장되어 있습니다.
**데이터 영역**에는 운영체제가 다룰 하드웨어와 소프트웨어의 자료구조들이 저장되어있습니다.
이 중 소프트웨어를 다룰 자료구조가 **PCB**입니다.
그리고 **스택영역**에는 프로세스별 커널 스택이 있는데 이곳에 프로세스가 운영체제에게 부탁한 함수의 리턴값이나 리턴할 주소등이 적혀있습니다.
<br/>

## PCB에는 어떤 것들이 저장되나요?

PCB가 저장하는 프로세스의 문맥은 다음과 같습니다.

- 운영체제가 관리상 사용하는 정보
  - **프로세스의 상태** : ready, running, blocked 등 현재 프로세스가 CPU를 갖고 있는지(running), 없다면 입출력작업을 기다리고 있어서 CPU할당을 못받는지(blocked), 아니면 CPU만 준다면 바로 실행이 가능한지(Ready)등의 상태
  - **프로세스 ID**: 프로세스를 식별하는 숫자
  - **스케줄링 정보, 우선순위** : CPU가 얼마나 빨리 이 프로세스를 다시 처리해야하는지

- CPU 수행 관련 하드웨어 값
  - **프로그램 카운터** : 바로 다음 수행될 명령어의 메모리 주소
  - **레지스터**: CPU가 연산할때 바로 필요한 데이터들(예를 들어 CPU가 덧셈계산을 한다면 1+2에서 1,2같은 계산할 때 바로 필요한 인자들)
- 메모리 관련
  - **프로세스의 주소공간(코드, 데이터, 스택)**의 위치 정보
- 파일 관련
  - 프로세스가 오픈한 파일 정보

<br/>
## 문맥 교환 과정

프로세스A에서 프로세스B로 문맥이 교환되는 과정은 대표적으로 **타이머 인터럽트**로 인해 프로세스A의 처리시간 초과와, 프로세스A가 OS의 기능을 필요로 해서 요청하는 **시스템 콜** 2가지가 있습니다.

타이머 인터럽트로 인한 문맥교환에 경우

1. CPU 제어권이 프로세스A로부터 운영체제로 이양  
2. 운영체제는 타이머 인터럽트 처리루틴으로 가서 직전까지 처리하던 프로세스의 문맥으로 PCB에 저장  
3. 이후 처리될 프로세스B에게 CPU 이양 
4. 기존 프로세스 A는 **Ready 상태**가 되어 **Ready 큐**에서 대기

> 준비큐: CPU가 할당만되면 바로 실행될 수 있는 프로세스들의 대기줄

시스템 콜로 인한 문맥교환도 위와 거의 똑같지만 기존 프로세스가 바로 실행가능한 준비상태가 되는것이 아니라 시스템콜에 의한 결과물을 기다리는 **Blocked 상태**가 됩니다.

>**Blocked(봉쇄) 상태**: CPU가 할당되면 바로 실행될 수 있는 Ready 상태와 달리 요청해둔 CPU이외의 작업(예: 입출력 작업)의 결과물이 있어야지만 이후 과정이 수행될 수 있는 상태  
예를 들어 음악 플레이어가 파일을 열어서(입출력작업) 재생시켜야되는데 음악이 열리기전까지는 CPU를 할당해봤자 음악을 재생시킬 수 없는데 이 상황을 Blocked(봉쇄) 상태라고 합니다.  
입출력 작업을 마쳐서 결과물을 받게 된다면 인터럽트에 의해 프로세스는 Blocked상태에서 Ready 상태로 바뀝니다.

## 문맥교환이 아닌것

위에서 문맥교환이 이루어지는 대표적이 2가지 경우에 대해 언급했었는데요.
입출력 인터럽트처럼 프로세스A가 실행중이다가 인터럽트 처리를 위해 운영체제에게 잠시 CPU제어권을 이양했다가 다시 프로세스 A에게 CPU 이양권이 돌아오는 것은 문맥교환이라고 하지 않습니다.

다시말해
프로세스 A -> 커널 모드 -> 프로세스 B
에서는 문맥교환이 일어나지만

프로세스 A -> 커널 모드 -> 프로세스 A
는 문맥교환없이 커널모드에서 사용자 모드로 복귀합니다.

문맥교환과 단순히 사용자모드, 커널모드의 전환에는 오버헤드에서 큰 차이가 있는데요.
예를 들어 문맥교환시는 cache에 담겨져있는 모든 정보를 지우지만(cache memory flush) 모드 변환에는 cache 정보를 지우지 않는다고 합니다.

<br/>
